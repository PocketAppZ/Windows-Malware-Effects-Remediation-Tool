using Microsoft.Win32;
using System;
using System.Diagnostics;
using System.IO;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using static System.Windows.Forms.VisualStyles.VisualStyleElement.StartPanel;
using static Windows_Malware_Effects_Remediation_Tool.RepairClasses;

namespace Windows_Malware_Effects_Remediation_Tool
{
    /// <summary>
    /// Interaction logic for AutomaticRepair.xaml
    /// </summary>
    public partial class AutomaticRepair : Window
    {
        public AutomaticRepair(bool separateDrive)
        {
            InitializeComponent();
            if (Convert.ToInt32(Registry.CurrentUser.OpenSubKey(@"SOFTWARE\Orange Group\Windows Malware Effects Remediation Tool").GetValue("TopMost")) == 1)
                this.Topmost = true;
            DiagnoseIssues();
            separateDriveFix = separateDrive;
        }

        public static bool separateDriveFix = false;

        private RepairClasses repairClasses = new RepairClasses();

        public async void DiagnoseIssues()
        {
            // Load Registry hives from target drive if separateDrive is true
            if (separateDriveFix == true)
            {
                LoadSeparateHive();
            }

            // Initialise HKLM and HKCU paths
            RegistryKey hklmSoftwarePath;
            RegistryKey hklmSystemPath;
            RegistryKey hkcuPath;

            if (separateDriveFix == true)
            {
                hklmSoftwarePath = Registry.LocalMachine.OpenSubKey(@"OfflineSoftware", true);
                hklmSystemPath = Registry.LocalMachine.OpenSubKey(@"OfflineSystem", true);
                hkcuPath = Registry.LocalMachine.OpenSubKey(@"OfflineUser", true);
            }
            else
            {
                hklmSoftwarePath = Registry.LocalMachine.OpenSubKey(@"SOFTWARE", true);
                hklmSystemPath = Registry.LocalMachine.OpenSubKey(@"SYSTEM", true);
                hkcuPath = Registry.CurrentUser;
            }

            // Iterate through the list of possible fixes and check if a fix is needed
            foreach (var fix in repairClasses.fixInformation)
            {
                var name = fix.Name;
                var fixType = fix.Type;
                var path = fix.Path;
                var key = fix.Key;
                var value = fix.Value;
                var nullable = fix.Nullable;

                for (int i = 0; i < fixType.Count; i++)
                {
                    if (fix.IsSelected == false)
                    {
                        if (fixType[i] == FixType.Registry)
                        {
                            // Determine Registry hive
                            RegistryKey registryKey;
                            if (path[i].Contains(@"HKEY_LOCAL_MACHINE\SOFTWARE"))
                            {
                                registryKey = hklmSoftwarePath.CreateSubKey(path[i].Replace(@"HKEY_LOCAL_MACHINE\SOFTWARE\", ""), true);
                            }
                            else if (path[i].Contains(@"HKEY_LOCAL_MACHINE\SYSTEM"))
                            {
                                registryKey = hklmSystemPath.CreateSubKey(path[i].Replace(@"HKEY_LOCAL_MACHINE\SYSTEM\", ""), true);
                            }
                            else if (path[i].Contains("HKEY_CURRENT_USER"))
                            {
                                registryKey = hkcuPath.CreateSubKey(path[i].Replace(@"HKEY_CURRENT_USER\", ""), true);
                            }
                            else
                            {
                                throw new Exception($@"The fix ""{name}"" was not configured correctly in RepairClasses: Invalid hive in Path (Registry)");
                            }

                            // If Registry key exists and value is incorrect, add to the checklistbox
                            if (registryKey.GetValue(key[i]) != null && registryKey.GetValue(key[i]).ToString() != value[i])
                            {
                                // Define binding
                                Binding binding = new Binding("RepairClasses.FixTask.IsSelected");
                                binding.NotifyOnSourceUpdated = true;
                                binding.UpdateSourceTrigger = UpdateSourceTrigger.PropertyChanged;

                                // Add to checklistbox
                                fix.IsSelected = true;
                                fixList.Items.Add(fix);
                            }
                            registryKey.Dispose();
                        }
                        else
                        {
                            // Add to checklistbox
                            CheckBox checkBox = new CheckBox();
                            checkBox.Content = name;
                            checkBox.IsChecked = true;
                            fixList.Items.Add(checkBox);
                            fix.IsSelected = true;
                        }
                    }
                }
            }

            // Show the checklistbox
            await Delay(5000); //time waster
            searchingForProblems.Visibility = Visibility.Collapsed;
            searchingForProblemsProgressBar.Visibility = Visibility.Collapsed;
            if (fixList.Items.Count == 0)
            {
                searchComplete.Visibility = Visibility.Visible;
                searchCompleteDescription.Visibility = Visibility.Visible;
                applyFix.Visibility = Visibility.Visible;
                fixList.Visibility = Visibility.Visible;
                goodToGo.Visibility = Visibility.Visible;
                applyFix.IsEnabled = false;
            }
            else
            {
                searchComplete.Visibility = Visibility.Visible;
                searchCompleteDescription.Visibility = Visibility.Visible;
                applyFix.Visibility = Visibility.Visible;
                fixList.Visibility = Visibility.Visible;
            }

            // Unload Registry hives if separateDrive is true
            if (separateDriveFix == true)
            {
                UnloadSeparateHive();
            }
        }

        private async void applyFix_Click(object sender, RoutedEventArgs e)
        {
            // Hide the checklistbox and show the progress bar
            searchComplete.Visibility = Visibility.Collapsed;
            searchCompleteDescription.Visibility = Visibility.Collapsed;
            applyFix.Visibility = Visibility.Collapsed;
            fixList.Visibility = Visibility.Collapsed;
            attemptingRepairs.Visibility = Visibility.Visible;
            attemptingRepairsProgressBar.Visibility = Visibility.Visible;
            repairProgress.Visibility = Visibility.Visible;

            // Load Registry hives from target drive if separateDrive is true
            if (separateDriveFix == true)
            {
                LoadSeparateHive();
            }

            // Initialise HKLM and HKCU paths
            RegistryKey hklmSoftwarePath;
            RegistryKey hklmSystemPath;
            RegistryKey hkcuPath;

            if (separateDriveFix == true)
            {
                hklmSoftwarePath = Registry.LocalMachine.OpenSubKey(@"OfflineSoftware", true);
                hklmSystemPath = Registry.LocalMachine.OpenSubKey(@"OfflineSystem", true);
                hkcuPath = Registry.LocalMachine.OpenSubKey(@"OfflineUser", true);
            }
            else
            {
                hklmSoftwarePath = Registry.LocalMachine.OpenSubKey(@"SOFTWARE", true);
                hklmSystemPath = Registry.LocalMachine.OpenSubKey(@"SYSTEM", true);
                hkcuPath = Registry.CurrentUser;
            }
            foreach (var fix in repairClasses.fixInformation)
            {
                var name = fix.Name;
                var fixType = fix.Type;
                var path = fix.Path;
                var key = fix.Key;
                var value = fix.Value;
                var nullable = fix.Nullable;

                for (int i = 0; i < fixType.Count; i++)
                {
                    if (fix.IsSelected == true)
                    {
                        if (fixType[i] == FixType.Registry)
                        {
                            // Determine Registry hive
                            RegistryKey registryKey;
                            if (path[i].Contains(@"HKEY_LOCAL_MACHINE\SOFTWARE"))
                            {
                                registryKey = hklmSoftwarePath.OpenSubKey(path[i].Replace(@"HKEY_LOCAL_MACHINE\SOFTWARE\", ""), true);
                            }
                            else if (path[i].Contains(@"HKEY_LOCAL_MACHINE\SYSTEM"))
                            {
                                registryKey = hklmSystemPath.OpenSubKey(path[i].Replace(@"HKEY_LOCAL_MACHINE\SYSTEM\", ""), true);
                            }
                            else if (path[i].Contains("HKEY_CURRENT_USER"))
                            {
                                registryKey = hkcuPath.OpenSubKey(path[i].Replace(@"HKEY_CURRENT_USER\", ""), true);
                            }
                            else
                            {
                                throw new Exception($@"The fix ""{name}"" was not configured correctly in RepairClasses: Invalid hive in Path (Registry)");
                            }

                            // Perform the fix
                            if (nullable[i] == true)
                            {
                                registryKey.DeleteValue(key[i]);
                            }
                            else
                            {
                                registryKey.SetValue(key[i], value[i]);
                            }

                            registryKey.Dispose();
                        } else
                        {
                            File.Delete(path[i]);
                        }
                    }
                    repairProgress.Content = $"Fixed {i+1} of {fixType.Count} issues";
                }
            }

            if (separateDriveFix == true)
            {
                UnloadSeparateHive();
            }
            
            // Show the success message
            await Delay(500);
            attemptingRepairs.Visibility = Visibility.Collapsed;
            attemptingRepairsProgressBar.Visibility = Visibility.Collapsed;
            repairProgress.Visibility = Visibility.Collapsed;
            repairSuccessful.Visibility = Visibility.Visible;
            repairSuccessfulCloseButton.Visibility = Visibility.Visible;
        }

        private async void LoadSeparateHive()
        {
            string mountPoint;
            string username;

            RegistryKey checkOperationsLocation = Registry.CurrentUser.OpenSubKey(@"SOFTWARE\Orange Group\Windows Malware Effects Remediation Tool", true);
            mountPoint = checkOperationsLocation.GetValue("MountPoint").ToString();
            username = checkOperationsLocation.GetValue("TargetUsername").ToString();

            Process loadHiveUser = new Process();
            loadHiveUser.StartInfo.FileName = "reg.exe";
            loadHiveUser.StartInfo.Arguments = @"load ""HKLM\OfflineUser"" """ + mountPoint + @"\Users\" + username + @"\NTUSER.dat" + @"""";
            loadHiveUser.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
            loadHiveUser.Start();

            Process loadHiveSoftware = new Process();
            loadHiveSoftware.StartInfo.FileName = "reg.exe";
            loadHiveSoftware.StartInfo.Arguments = @"load ""HKLM\OfflineSoftware"" """ + mountPoint + @"\Windows\System32\config\SOFTWARE" + @"""";
            loadHiveSoftware.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
            loadHiveSoftware.Start();

            Process loadHiveSystem = new Process();
            loadHiveSystem.StartInfo.FileName = "reg.exe";
            loadHiveSystem.StartInfo.Arguments = @"load ""HKLM\OfflineSystem"" """ + mountPoint + @"\Windows\System32\config\SYSTEM" + @"""";
            loadHiveSystem.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
            loadHiveSystem.Start();
            await Delay(500);
        }

        private void UnloadSeparateHive()
        {
            Process unloadHiveUser = new Process();
            unloadHiveUser.StartInfo.FileName = "reg.exe";
            unloadHiveUser.StartInfo.Arguments = @"unload ""HKLM\OfflineUser""";
            unloadHiveUser.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
            unloadHiveUser.Start();

            Process unloadHiveSoftware = new Process();
            unloadHiveSoftware.StartInfo.FileName = "reg.exe";
            unloadHiveSoftware.StartInfo.Arguments = @"unload ""HKLM\OfflineSoftware""";
            unloadHiveSoftware.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
            unloadHiveSoftware.Start();

            Process unloadHiveSystem = new Process();
            unloadHiveSystem.StartInfo.FileName = "reg.exe";
            unloadHiveSystem.StartInfo.Arguments = @"unload ""HKLM\OfflineSystem""";
            unloadHiveSystem.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
            unloadHiveSystem.Start();
        }

        private async void Delay(int howlong)
        {
            await Task.Delay(howlong);
        }

        private void repairSuccessfulCloseButton_Click(object sender, EventArgs e)
        {
            this.Close();
        }
    }
}
